#+TITLE: Notes
** What additional attribute does each vertex need to get a texture drawn onto the triangle?
   Texture coorinates
** What is the range of values for a texture coordinate?
   0 to 1

   [[file:resources/tex_coords.png][tex_coords.jpg]]
** What is called when when you retrieve the color of a texture with a texture coordinate?
   Sampling
** What happens when we tried to give a texture coordinate to a vertex that is outside of the 0 to 1 range?
   The default behavior of OpenGL is to repeat the texture images (we basically ignore the integer part of the floating point texture coordinate)
** What other options does OpenGL offer when you give a texture coordinate outside of the 0 to 1 range?
   - GL_REPEAT: The default behavior for textures. Repeats the texture image.
   - GL_MIRRORED_REPEAT: Same as GL_REPEAT but mirrors the image with each repeat.
   - GL_CLAMP_TO_EDGE: Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern.
   - GL_CLAMP_TO_BORDER: Coordinates outside the range are now given a user-specified border color.

     Here's what each of those look like:

     [[file:resources/Capture.PNG][wrap]]
** To set the wrapping option (as mentioned when coordinates lie outside the 0 to 1 range), use the glTexParameteri function. What are the arguments?
   Here's an example implementation:

   #+BEGIN_SRC 
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
   #+END_SRC

   - The first argument specifies the texture target; we're working with 2D textures so the texture target is GL_TEXTURE_2D
   - The second argument requires us to tell what option we want to set and for which texture axis. We want to configure the WRAP option and specify it for both the S and T axis
   - The last argument requires us to pass in the texture wrapping mode we'd like and in this case OpenGL will set its texture wrapping option on the currently active texture with GL_MIRRORED_REPEAT
** How do you specify the border color when using the GL_CLAMP_BORDER option?
   If we choose the GL_CLAMP_TO_BORDER option we should also specify a border color. This is done using the fv equivalent of the glTexParameter function with GL_TEXTURE_BORDER_COLOR as its option where we pass in a float array of the border's color value:

   #+BEGIN_SRC 
   float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
   glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
   #+END_SRC
** OpenGL needs a bit more info to map the texture coordinate to the nearest texture pixel (texel). What options are there?
   GL_NEAREST and GL_LINEAR

   [[file:resources/tex_filtering.PNG][tex_filtering.png]]
** Describe how OpenGL uses the GL_NEAREST to map a texture coordinate to the appropriate texel
   GL_NEAREST (also known as nearest neighbor filtering) is the default texture filtering method of OpenGL. When set to GL_NEAREST, OpenGL selects the pixel which center is closest to the texture coordinate. Below you can see 4 pixels where the cross represents the exact texture coordinate. The upper-left texel has its center closest to the texture coordinate and is therefore chosen as the sampled color
** Describe how OpenGL uses the GL_LINEAR to map a texture coordinate to the appropriate texel
   GL_LINEAR (also known as (bi)linear filtering) takes an interpolated value from the texture coordinate's neighboring texels, approximating a color between the texels. The smaller the distance from the texture coordinate to a texel's center, the more that texel's color contributes to the sampled color. Below we can see that a mixed color of the neighboring pixels is returned
** When you have an object that is far away that is using a texture, the fragments that OpenGL creates will have a hard time matching a texture coordinate to a texel because the object is so small. How does OpenGL get around this issue?
   OpenGL creates mipmaps. Mipmaps are basically duplicate textures with the same texture of smaller sizes appended to the original

   [[file:resources/mipmap.PNG][mipmap.png]]
** How and when do you create mipmaps?
   After you've generated a texture, you can create a mipmap. It is done by running glGenerateMipmaps
** When transitioning between different texture subsets of a mipmap in a scene, you will still get artifacts just like in texture filtering. How can you mitigate this?
   Just like with regular textures, you can turn use the NEAREST or LINEAR filter
** What are the four mipmap texture filters?
   - GL_NEAREST_MIPMAP_NEAREST: takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling.
   - GL_LINEAR_MIPMAP_NEAREST: takes the nearest mipmap level and samples using linear interpolation.
   - GL_NEAREST_MIPMAP_LINEAR: linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples via nearest neighbor interpolation.
   - GL_LINEAR_MIPMAP_LINEAR: linearly interpolates between the two closest mipmaps and samples the texture via linear interpolation.
** There are many different image types thus many different types of images we can load as textures. Instead of creating our own user-defined functions to load different types, what can you do?
   You can use the [[https://github.com/nothings/stb/blob/master/stb_image.h][stb_image.h]] file created by Sean Barrett
** How do you use the stb_image.h file in your project
   Unfortunately, you can't just load it into the application. You have to create a cpp file and include the following:

   #+BEGIN_SRC 
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"
   #+END_SRC

   By defining STB_IMAGE_IMPLEMENTATION the preprocessor modifies the header file such that it only contains the relevant definition source code, effectively turning the header file into a .cpp file, and that's about it
** How to you create a texture?
   - You can start to generate a texture just like you would with previous OpenGL obejects:

     #+BEGIN_SRC 
     unsigned int texture;
     glGenTextures(1, &texture);
     #+END_SRC

     Then of course, we need to bind it

     #+BEGIN_SRC 
     glBindTexture(GL_TEXTURE_2D, texture);
     #+END_SRC

   - Next, we actually generate the texture:

     #+BEGIN_SRC 
     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
     glGenerateMipmap(GL_TEXTURE_2D);
     #+END_SRC
     
     Here's what each argument does:

     - The first argument specifies the texture target; setting this to GL_TEXTURE_2D means this operation will generate a texture on the currently bound texture object at the same target (so any textures bound to targets GL_TEXTURE_1D or GL_TEXTURE_3D will not be affected).
     - The second argument specifies the mipmap level for which we want to create a texture for if you want to set each mipmap level manually, but we'll leave it at the base level which is 0.
     - The third argument tells OpenGL in what kind of format we want to store the texture. Our image has only RGB values so we'll store the texture with RGB values as well.
     - The 4th and 5th argument sets the width and height of the resulting texture. We stored those earlier when loading the image so we'll use the corresponding variables.
     - The next argument should always be 0 (some legacy stuff).
     - The 7th and 8th argument specify the format and datatype of the source image. We loaded the image with RGB values and stored them as chars (bytes) so we'll pass in the corresponding values.
     - The last argument is the actual image data
** What is a sampler?
   In order to actually generate the final texture in the fragment shader, the shader needs access to the texture data. In GLSL, we can declare sampler1D,2D or 3D. We then use this sampler to create the final texture in the fragment shader (see the fragment shader file in this directory)
** What is a texture unit?
   If you remember in the fragment shader, we created a uniform datatype called sampler2d (sampler2d is a sampler datatype, so we're kind of defining the final variable as being two datatypes. Read the previous notes on uniforms from the shader tutorial and samplers from this file if you don't understand).

   Well if you remember, we didn't actually do anything with this uniform. We never called it in the cpp file. The reason we created a uniform datatype though was because OpenGL offers the ability to use multiple textures for one object. Before this part of the tutorial, we only had one texture though, so it didn't really matter anyway. Using the glUniform1i function, we can actually assign a location to the sampler (of different textures). Since we only had one texture, its location defaulted to 0. If we wanted to add another texture though, we would use that function to tell it its location (probably 1).

   OpenGL offers 16 locations (GL_TEXTURE0-GL_TEXTURE15)
