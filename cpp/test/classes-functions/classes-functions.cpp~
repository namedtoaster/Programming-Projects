// This particular file was created because I realized I didn't know exactly
// all the different ways functions could be called/declared. The basic things
// one should know is the kind of return value the function will return and the
// parameters that the function operates on. These parameters are only "alive"
// within the scope of the function (that's a topic for another practice file).
// The first thing to go through is declaring a constant function

// I will surely come back to this file often because there are lots of things
// to cover.

#include <iostream>

using namespace std;

class Test {
private:
  int value;
public:
  Test(int x = 0) { value = x; }
  // get_value() simply returns the value of member variable 'value'. Since
  // the function is declared as a const type, if we try to modify any of
  // the class's member variables, the compiler will yell at us like it does
  // when....
  int get_value() const { cout << "**const method** "; return value; }

  // ...we try to compile this function:
  /*void set_value(int x = 0) const
    { value = x; }*/

  int get_value() { cout << "**non-const method** "; return value; }
};

void print_something() { cout << "something" << endl; }
// Note that these two functions are exactly the same. If you try tod eclare
// both functions, the compiler will give you a redefinition error
//void print_something(void) { cout << "something (void parameter)" << endl;

int main() {
  Test a(5);

  // Just test the first method...
  cout << "a's (of class Test) value: " << a.get_value() << endl;

  const Test b(10);
  // Which get_value() function will b call?
  cout << "b's (of class Test) value: " << b.get_value() << endl;

  // While going through some documentation found on Google, I found that it is not
  // possible for a const type to call a non-const function. Somewhat unsurprisingly,
  // if you have two functions with the same name, the const instance will call the
  // method that is of the const type. If you comment out the const method, the
  // compiler will throw an error

  print_something();
}
